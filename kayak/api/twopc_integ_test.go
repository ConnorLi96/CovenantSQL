/*
 * Copyright 2018 The CovenantSQL Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"context"
	"crypto/rand"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"sync"
	"testing"
	"time"

	"github.com/CovenantSQL/CovenantSQL/crypto/asymmetric"
	"github.com/CovenantSQL/CovenantSQL/crypto/hash"
	"github.com/CovenantSQL/CovenantSQL/crypto/kms"
	"github.com/CovenantSQL/CovenantSQL/kayak"
	"github.com/CovenantSQL/CovenantSQL/pow/cpuminer"
	"github.com/CovenantSQL/CovenantSQL/proto"
	"github.com/CovenantSQL/CovenantSQL/route"
	"github.com/CovenantSQL/CovenantSQL/rpc"
	"github.com/CovenantSQL/CovenantSQL/twopc"
	"github.com/CovenantSQL/CovenantSQL/utils/log"
	. "github.com/smartystreets/goconvey/convey"
	"github.com/stretchr/testify/mock"
)

// MockWorker is an autogenerated mock type for the Worker type
type MockWorker struct {
	mock.Mock
}

// Commit provides a mock function with given fields: ctx, wb
func (_m *MockWorker) Commit(ctx context.Context, wb twopc.WriteBatch) (interface{}, error) {
	ret := _m.Called(context.Background(), wb)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(context.Context, twopc.WriteBatch) interface{}); ok {
		r0 = rf(ctx, wb)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, twopc.WriteBatch) error); ok {
		r1 = rf(ctx, wb)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Prepare provides a mock function with given fields: ctx, wb
func (_m *MockWorker) Prepare(ctx context.Context, wb twopc.WriteBatch) error {
	ret := _m.Called(context.Background(), wb)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, twopc.WriteBatch) error); ok {
		r0 = rf(ctx, wb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Rollback provides a mock function with given fields: ctx, wb
func (_m *MockWorker) Rollback(ctx context.Context, wb twopc.WriteBatch) error {
	ret := _m.Called(context.Background(), wb)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, twopc.WriteBatch) error); ok {
		r0 = rf(ctx, wb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type CallCollector struct {
	l         sync.Mutex
	callOrder []string
}

func (c *CallCollector) Append(call string) {
	c.l.Lock()
	defer c.l.Unlock()
	c.callOrder = append(c.callOrder, call)
}

func (c *CallCollector) Get() []string {
	c.l.Lock()
	defer c.l.Unlock()
	return c.callOrder[:]
}

func (c *CallCollector) Reset() {
	c.l.Lock()
	defer c.l.Unlock()
	c.callOrder = c.callOrder[:0]
}

type mockRes struct {
	rootDir    string
	nodeID     proto.NodeID
	worker     *MockWorker
	server     *rpc.Server
	config     kayak.Config
	runtime    *kayak.Runtime
	listenAddr string
}

func initKMS() (err error) {
	var f *os.File
	f, err = ioutil.TempFile("", "keystore_")
	f.Close()
	os.Remove(f.Name())
	route.InitKMS(f.Name())

	// flag as test
	kms.Unittest = true

	return
}

func testWithNewNode() (mock *mockRes, err error) {
	mock = &mockRes{}
	addr := "127.0.0.1:0"

	// random node id
	randBytes := make([]byte, 4)
	rand.Read(randBytes)
	mock.nodeID = proto.NodeID(hash.THashH(randBytes).String())
	kms.SetLocalNodeIDNonce(mock.nodeID.ToRawNodeID().CloneBytes(), &cpuminer.Uint256{})

	// mock rpc server
	mock.server, err = rpc.NewServerWithService(rpc.ServiceMap{})
	if err != nil {
		return
	}
	_, testFile, _, _ := runtime.Caller(0)
	privKeyPath := filepath.Join(filepath.Dir(testFile), "../../test/node_standalone/private.key")
	if err = mock.server.InitRPCServer(addr, privKeyPath, []byte("")); err != nil {
		return
	}
	mock.listenAddr = mock.server.Listener.Addr().String()
	route.SetNodeAddrCache(mock.nodeID.ToRawNodeID(), mock.listenAddr)
	var nonce *cpuminer.Uint256
	if nonce, err = kms.GetLocalNonce(); err != nil {
		return
	}
	var pubKey *asymmetric.PublicKey
	if pubKey, err = kms.GetLocalPublicKey(); err != nil {
		return
	}
	if err = kms.SetPublicKey(mock.nodeID, *nonce, pubKey); err != nil {
		return
	}

	// create mux service for kayak
	service := NewMuxService("Kayak", mock.server)
	mock.rootDir, err = ioutil.TempDir("", "kayak_test")
	if err != nil {
		return
	}

	// worker
	mock.worker = &MockWorker{}

	// create two pc config
	options := NewTwoPCOptions().
		WithNodeID(mock.nodeID).
		WithProcessTimeout(time.Millisecond * 300).
		WithTransportID(DefaultTransportID).
		WithLogger(log.StandardLogger())
	mock.config = NewTwoPCConfigWithOptions(mock.rootDir, service, mock.worker, options)

	return
}

func createRuntime(peers *kayak.Peers, mock *mockRes) (err error) {
	mock.runtime, err = NewTwoPCKayak(peers, mock.config)
	return
}

func testPeersFixture(term uint64, servers []*kayak.Server) *kayak.Peers {
	testPriv := []byte{
		0xea, 0xf0, 0x2c, 0xa3, 0x48, 0xc5, 0x24, 0xe6,
		0x39, 0x26, 0x55, 0xba, 0x4d, 0x29, 0x60, 0x3c,
		0xd1, 0xa7, 0x34, 0x7d, 0x9d, 0x65, 0xcf, 0xe9,
		0x3c, 0xe1, 0xeb, 0xff, 0xdc, 0xa2, 0x26, 0x94,
	}
	privKey, pubKey := asymmetric.PrivKeyFromBytes(testPriv)

	newServers := make([]*kayak.Server, 0, len(servers))
	var leaderNode *kayak.Server

	for _, s := range servers {
		newS := &kayak.Server{
			Role:   s.Role,
			ID:     s.ID,
			PubKey: pubKey,
		}
		newServers = append(newServers, newS)
		if newS.Role == proto.Leader {
			leaderNode = newS
		}
	}

	peers := &kayak.Peers{
		Term:    term,
		Leader:  leaderNode,
		Servers: servers,
		PubKey:  pubKey,
	}

	peers.Sign(privKey)

	return peers
}

func TestExampleTwoPCCommit(t *testing.T) {
	// cleanup log storage after execution
	cleanupDir := func(c *mockRes) {
		os.RemoveAll(c.rootDir)
	}

	// only commit logic
	Convey("commit", t, func() {
		var err error

		err = initKMS()
		So(err, ShouldBeNil)

		lMock, err := testWithNewNode()
		So(err, ShouldBeNil)
		f1Mock, err := testWithNewNode()
		So(err, ShouldBeNil)
		f2Mock, err := testWithNewNode()
		So(err, ShouldBeNil)

		// peers is a simple 3-node peer configuration
		peers := testPeersFixture(1, []*kayak.Server{
			{
				Role: proto.Leader,
				ID:   lMock.nodeID,
			},
			{
				Role: proto.Follower,
				ID:   f1Mock.nodeID,
			},
			{
				Role: proto.Follower,
				ID:   f2Mock.nodeID,
			},
		})
		defer cleanupDir(lMock)
		defer cleanupDir(f1Mock)
		defer cleanupDir(f2Mock)

		// create runtime
		err = createRuntime(peers, lMock)
		So(err, ShouldBeNil)
		err = createRuntime(peers, f1Mock)
		So(err, ShouldBeNil)
		err = createRuntime(peers, f2Mock)
		So(err, ShouldBeNil)

		// init
		err = lMock.runtime.Init()
		So(err, ShouldBeNil)
		err = f1Mock.runtime.Init()
		So(err, ShouldBeNil)
		err = f2Mock.runtime.Init()
		So(err, ShouldBeNil)

		// make request issuer as leader node
		kms.SetLocalNodeIDNonce(lMock.nodeID.ToRawNodeID().CloneBytes(), &cpuminer.Uint256{})

		// payload to send
		testPayload := []byte("test data")

		// underlying worker mock, prepare/commit/rollback with be received the decoded data
		callOrder := &CallCollector{}
		f1Mock.worker.On("Prepare", mock.Anything, testPayload).
			Return(nil).Run(func(args mock.Arguments) {
			callOrder.Append("prepare")
		})
		f2Mock.worker.On("Prepare", mock.Anything, testPayload).
			Return(nil).Run(func(args mock.Arguments) {
			callOrder.Append("prepare")
		})
		f1Mock.worker.On("Commit", mock.Anything, testPayload).
			Return(nil, nil).Run(func(args mock.Arguments) {
			callOrder.Append("commit")
		})
		f2Mock.worker.On("Commit", mock.Anything, testPayload).
			Return(nil, nil).Run(func(args mock.Arguments) {
			callOrder.Append("commit")
		})
		lMock.worker.On("Prepare", mock.Anything, testPayload).
			Return(nil).Run(func(args mock.Arguments) {
			callOrder.Append("prepare")
		})
		lMock.worker.On("Commit", mock.Anything, testPayload).
			Return(nil, nil).Run(func(args mock.Arguments) {
			callOrder.Append("commit")
		})

		// start server
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			lMock.server.Serve()
		}()
		wg.Add(1)
		go func() {
			defer wg.Done()
			f1Mock.server.Serve()
		}()
		wg.Add(1)
		go func() {
			defer wg.Done()
			f2Mock.server.Serve()
		}()

		// process the encoded data
		_, _, err = lMock.runtime.Apply(testPayload)
		So(err, ShouldBeNil)
		So(callOrder.Get(), ShouldResemble, []string{
			"prepare",
			"prepare",
			"prepare",
			"commit",
			"commit",
			"commit",
		})

		// process the encoded data again
		callOrder.Reset()
		_, _, err = lMock.runtime.Apply(testPayload)
		So(err, ShouldBeNil)
		So(callOrder.Get(), ShouldResemble, []string{
			"prepare",
			"prepare",
			"prepare",
			"commit",
			"commit",
			"commit",
		})

		// shutdown
		lMock.runtime.Shutdown()
		f1Mock.runtime.Shutdown()
		f2Mock.runtime.Shutdown()

		// close
		lMock.server.Listener.Close()
		f1Mock.server.Listener.Close()
		f2Mock.server.Listener.Close()
		lMock.server.Stop()
		f1Mock.server.Stop()
		f2Mock.server.Stop()

		wg.Wait()
	})
}
